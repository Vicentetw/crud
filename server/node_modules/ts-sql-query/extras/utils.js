"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeType = exports.extractColumnsFrom = exports.prefixMapForGuidedSplitDotted = exports.prefixMapForSplitDotted = exports.prefixDotted = exports.mapForGuidedSplit = exports.prefixMapForGuidedSplitCapitalized = exports.prefixMapForSplitCapitalized = exports.prefixCapitalized = void 0;
const values_1 = require("../expressions/values");
const Column_1 = require("../utils/Column");
function prefixCapitalized(obj, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        result[prefix + key.substr(0, 1).toUpperCase() + key.substr(1)] = obj[key];
    }
    return result;
}
exports.prefixCapitalized = prefixCapitalized;
function prefixMapForSplitCapitalized(obj, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        result[key] = prefix + key.substr(0, 1).toUpperCase() + key.substr(1);
    }
    return result;
}
exports.prefixMapForSplitCapitalized = prefixMapForSplitCapitalized;
function prefixMapForGuidedSplitCapitalized(obj, reference, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        const r = reference[key];
        if ((0, values_1.isValueSource)(r) && (0, values_1.__getValueSourcePrivate)(r).__optionalType === 'required') {
            result[key] = prefix + key.substr(0, 1).toUpperCase() + key.substr(1) + '!';
        }
        else {
            result[key] = prefix + key.substr(0, 1).toUpperCase() + key.substr(1);
        }
    }
    return result;
}
exports.prefixMapForGuidedSplitCapitalized = prefixMapForGuidedSplitCapitalized;
function mapForGuidedSplit(obj, reference) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        const r = reference[key];
        if ((0, values_1.isValueSource)(r) && (0, values_1.__getValueSourcePrivate)(r).__optionalType === 'required') {
            result[key] = key + '!';
        }
        else {
            result[key] = key;
        }
    }
    return result;
}
exports.mapForGuidedSplit = mapForGuidedSplit;
function prefixDotted(obj, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        result[prefix + '.' + key] = obj[key];
    }
    return result;
}
exports.prefixDotted = prefixDotted;
function prefixMapForSplitDotted(obj, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        result[key] = prefix + '.' + key;
    }
    return result;
}
exports.prefixMapForSplitDotted = prefixMapForSplitDotted;
function prefixMapForGuidedSplitDotted(obj, reference, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        const r = reference[key];
        if ((0, values_1.isValueSource)(r) && (0, values_1.__getValueSourcePrivate)(r).__optionalType === 'required') {
            result[key] = prefix + '.' + key + '!';
        }
        else {
            result[key] = prefix + '.' + key;
        }
    }
    return result;
}
exports.prefixMapForGuidedSplitDotted = prefixMapForGuidedSplitDotted;
function extractColumnsFrom(obj) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        const value = obj[key];
        if ((0, Column_1.isColumn)(value)) {
            result[key] = value;
        }
    }
    return result;
}
exports.extractColumnsFrom = extractColumnsFrom;
function mergeType(value) {
    return value;
}
exports.mergeType = mergeType;
